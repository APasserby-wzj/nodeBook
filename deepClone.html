<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
	<link rel="stylesheet" href="prism.css">
    <title>王志江</title>
</head>
<body>
	<h1>随笔</h1>
	<!-- JavaScript代码 -->
	<!-- 使用行号插件和高亮插件 -->
	<!-- 深克隆 -->
	<pre class="line-numbers">
		<code class="language-javascript">//深克隆
			var obj = {
			    a: '你好',
			    b: {
			        a:'第二层'
			    },
			    c: new Date(),
			    d: [1,2,3,4],
			    e:/^[a-zA-Z]\w{5,9}$/,
			    i:function(b){
			        b='iii'
			        return b 
			    }
			}
			//方法1  也是工作中最常用的，此方法有缺陷，遇到对象或数组里的日期对象会将其转换为字符串格式、正则对象变成'{}'、函数直接丢弃了
			console.log('方法一',JSON.parse(JSON.stringify(obj)))
			// {a: "你好", b: {…}, c: "2020-07-31T00:55:00.803Z", d: Array(4), e: {…}}
			// a: "你好"
			// b: {a: "第二层"}
			// c: "2020-07-31T00:55:00.803Z"
			// d: (4) [1, 2, 3, 4]
			// e: {}
			// __proto__: Object
			
			//方法2  该方法是方法1的进阶 处理了下正则对象、日期对象问题，以及函数引用了下（这个函数只实现了浅拷贝）
			function deepClone(param){
				//先排除参数是基本数据类型的情况
			    if(param == null || typeof param !== 'paramect' ) return param;
				// 正则对象
			    if(param instanceof RegExp) return new RegExp(param)
				// 日期对象
			    if(param instanceof Date) return new Date(param)
				let result;
				if(param instanceof Array){
					rusult = []
				}else if(param instanceof Object){
					rusult = {}
				}
				for(const key in param){
					if(param.hasOwnProperty(key)){
						rusult[key] = deepClone(param[key])
					}
				}
				return rusult
			}
			console.log('方法二',deepClone(obj))
			// Object
			// a: "你好"
			// b: {a: "第二层"}
			// c: Fri Jul 31 2020 08:50:25 GMT+0800 (中国标准时间) {}
			// d: (4) [1, 2, 3, 4]
			// e: /^[a-zA-Z]\w{5,9}$/
			// i: ƒ (b)
			// __proto__: Object
			
			
			// 方法3 这个方法涵盖了所有引用数据类型，根据js的所有引用类型的值都是Object的实例这一原理实现的	
			// 定义检测要处理数据类型参数
			function typeAll(param){
				return Object.prototype.toString.call(param).slice(8,-1)
			}
			function colne(param){
				//判断数据类型
				let rusult, type = typeAll(param)
				if(type === 'object'){
					rusult = {}
				}else if(type === 'array'){
					rusult = []
				}else{
					return param
				}
				// 遍历数据
				for(let i in param){
					let item = param[i]
					if(typeAll(item) === 'object' || typeAll(item) === 'array'){
						result[i] = colne(item)
					}else {
						result[i] = item
					}
				}
				return result
			}
			console.log('方法三',colne(obj))
			// {a: "你好", b: {…}, c: Fri Jul 31 2020 11:31:45 GMT+0800 (中国标准时间), d: Array(4), e: /^[a-zA-Z]\w{5,9}$/, …}
			// a: "你好"
			// b: {a: "第二层"}
			// c: Fri Jul 31 2020 11:31:45 GMT+0800 (中国标准时间) {}
			// d: (4) [1, 2, 3, 4]
			// e: /^[a-zA-Z]\w{5,9}$/
			// i: ƒ (b)
			// length: 1
			// name: "i"
			// arguments: null
			// caller: null
			// prototype: {constructor: ƒ}
			// __proto__: ƒ ()
			// [[FunctionLocation]]: deepClone.html:116
			// [[Scopes]]: Scopes[1]
			// __proto__: Object
			//剩下的引用库的方法就有很多了   比例lodash 的cloneDeep jQ的 entend 等
			
			
		</code>
		
	</pre>
	<!-- 闭包 -->
	<pre class="line-numbers">
		<code class="language-javascript">//闭包
		你是怎么理解闭包的：
			1. 什么是闭包以及他的产生  => 基础扎实
				+ 堆栈内存
				+ ECStack、Heap、EC、GO、VO、AO、Scope、ScopeChain
					+ ECStack（栈内存）执行环境栈是浏览器专门在计算机内存中分配的一块内存，提供代码执行环境
					+ Heap（堆内存）存放属性和方法的地方
					+ EC(Execution Context)(执行上下文) 在代码执行中，为了区分全局和函数执行所处不同的作用域形成了执行上下文
					+ GO(Variable object)（全局对象）一般指window 是浏览器为了存放内置属性和方法开辟的一块堆内存
					+ VO(Variable object)（变量对象）在每个非函数上下文代码执行的时候，都可能会创建的一个对象。
					+ AO(Activation object)（活动对象）函数的执行环境是在调用的时候创建的，在创建上下文的时候会对应创建的一个对象
					+ Scope（作用域）当前执行上下文的范围
					+ ScopeChain（作用域链）作用域链是用来保证对执行环境有权访问的所有变量和函数的有序访问
				+ 浏览器垃圾回收机制
					浏览器为了确保正常工作性能设置的一种回收机制，一般分为两种，一种是标记清除，一种是引用计数。各大浏览器常用的是前者
					 + 标记清除法  是指当变量进入环境时，将变量标记‘进入环境’，当变量离开环境时，将其标记为‘离开环境’。
						在某一时刻，垃圾回收器会过滤掉环境中的变量，以及被环境变量引用的变量。剩下的就是被视为准备销毁回收的变量
					 + 引用计数法  是指跟踪记录每个值被引用的次数，引用一次就加1，当这个被引用计数为0时，就会被视为准备销毁回收的对象
			2. 优缺点和作用
				+ 保护 
				+ 保存
			3. 分析应用场景  => 实战应用和处理思维
				+ 循环事件绑定
				+ let
				+ 单例设计模式
				+ 高阶函数：惰性函数、柯理化函数、compose函数 
			4. 源码分析   => 阅读源码的能力
				+ JQ源码
				+ 函数的防抖和节流
				+ bind
				+ ...  (react中的高阶组件/redux源码/react-redux源码)
			5. 自己的开源作品   =>进阶自我
			
			
			===========> 只讲核心，不展开细节描述（引导他问你）"点到为止"
			===========> 加入一些引导过渡语：自己大量研究：项目中遇到问题后专门去搞了搞：我先把我了解的和您说一遍，您看看那里还没有说到的，再帮我指点一下：加入一些场景
			
			
			
			
		</code>
		
	</pre>
	<!--面向对象 -->
	<pre class="line-numbers">
		<code class="language-javascript">//闭包
		你是怎么理解面向对象的：
			1. 基础理论
				+ 面向对象和面向过程
				+ 类/实例（包含类的继承封装和多态）
				+ new构造函数
				+ __proto__和prototype
				+ ...
			2. 应用场景
				+ 应用它的思想：借用数组方法实现类数组的处理、数据类型检测、基于内置类重写方法
				+ 插件组件的封装
					+ 突出自己在项目中封装过哪些插件
					+ 大体怎么封装的（核心思想）
					+ API数据以及带来的效果
				+ ...
			3. 研究源码
				+ JQ
				+ Lodash
				+ Vue/React...
				+ ...
		</code>
		
	</pre>
	<!--原型链 -->
	<pre class="line-numbers">
		<code class="language-javascript">//闭包
		你是怎么理解面向对象的：
			1. 基础理论
				+ 面向对象和面向过程
				+ 类/实例（包含类的继承封装和多态）
				+ new构造函数
				+ __proto__和prototype
				+ ...
			2. 应用场景
				+ 应用它的思想：借用数组方法实现类数组的处理、数据类型检测、基于内置类重写方法
				+ 插件组件的封装
					+ 突出自己在项目中封装过哪些插件
					+ 大体怎么封装的（核心思想）
					+ API数据以及带来的效果
				+ ...
			3. 研究源码
				+ JQ
				+ Lodash
				+ Vue/React...
				+ ...
		</code>
	</pre>
	<!--继承 -->
	<pre class="line-numbers">
		<code class="language-javascript">//闭包
		你是怎么理解面向对象的：
			1. 基础理论
				+ 面向对象和面向过程
				+ 类/实例（包含类的继承封装和多态）
				+ new构造函数
				+ __proto__和prototype
				+ ...
			2. 应用场景
				+ 应用它的思想：借用数组方法实现类数组的处理、数据类型检测、基于内置类重写方法
				+ 插件组件的封装
					+ 突出自己在项目中封装过哪些插件
					+ 大体怎么封装的（核心思想）
					+ API数据以及带来的效果
				+ ...
			3. 研究源码
				+ JQ
				+ Lodash
				+ Vue/React...
				+ ...
		</code>
		
	</pre>
	<!--一道面试题引发的8问 -->
	<pre class="line-numbers">
		<code class="language-javascript">//闭包
		1. 数据类型检测办法
			大体有四种  typeof instanceof constructor Object.prototype.toString.call()
		2. 四种方式的区别
			+ typeof
		3. typeof null为啥是object
			原理是这样的。不同的对象在底层都表示为二进制，在javascript中二进制前三位都为0的话会被判断为object类型，
			null的二进制表示全0，自然前三位也是0，所以执行typeof时会返回“object”
		4. instanceof的原理及重写
			
		5. Object.prototype.toString.call原理
		6. Symbol和BigInt的特殊性
		7. 项目中你都会使用哪些办法，为啥
		8. 如果让你封装的一个toType检测类型你会怎么写
		9. 检测是数组或者类数组以及纯粹的对象你会怎么做
		</code>
		
	</pre>
	
    <script src="prism.js"></script>
</body>
    <script>
		// document.getElementsByTagName('pre').addClass("line-numbers").css("white-space", "pre-wrap");
        var obj = {
            a: '你好',
            b: {
                a:'第二层'
            },
            c: new Date(),
            d: [1,2,3,4],
            e:/^[a-zA-Z]\w{5,9}$/,
            i:function(b){
                b='iii'
                return b 
            }
        }
		//方法1  也是工作中最常用的，此方法有缺陷，遇到对象或数组里的日期对象会将其转换为字符串格式、正则对象变成'{}'、函数直接丢弃了
		console.log('方法一',JSON.parse(JSON.stringify(obj)))
		// {a: "你好", b: {…}, c: "2020-07-31T00:55:00.803Z", d: Array(4), e: {…}}
		// a: "你好"
		// b: {a: "第二层"}
		// c: "2020-07-31T00:55:00.803Z"
		// d: (4) [1, 2, 3, 4]
		// e: {}
		// __proto__: Object
		
		//方法2  该方法是方法1的进阶 处理了下正则对象、日期对象问题，以及函数引用了下（这个函数只实现了浅拷贝）
        function deepClone(param){
        	//先排除参数是基本数据类型的情况
            if(param == null || typeof param !== 'paramect' ) return param;
        	// 正则对象
            if(param instanceof RegExp) return new RegExp(param)
        	// 日期对象
            if(param instanceof Date) return new Date(param)
        	let result;
        	if(param instanceof Array){
        		rusult = []
        	}else if(param instanceof Object){
        		rusult = {}
        	}
        	for(const key in param){
        		if(param.hasOwnProperty(key)){
        			rusult[key] = deepClone(param[key])
        		}
        	}
        	return rusult
        }
        console.log('方法二',deepClone(obj))
		// Object
		// a: "你好"
		// b: {a: "第二层"}
		// c: Fri Jul 31 2020 08:50:25 GMT+0800 (中国标准时间) {}
		// d: (4) [1, 2, 3, 4]
		// e: /^[a-zA-Z]\w{5,9}$/
		// i: ƒ (b)
		// __proto__: Object
		
		
		// 方法3 这个方法涵盖了所有引用数据类型，根据js的所有引用类型的值都是Object的实例这一规则实现的	
		// 定义检测要处理数据类型参数
		function typeAll(param){
			return Object.prototype.toString.call(param).slice(8,-1)
		}
		function colne(param){
			//判断数据类型
			let rusult, type = typeAll(param)
			if(type === 'object'){
				rusult = {}
			}else if(type === 'array'){
				rusult = []
			}else{
				return param
			}
			// 遍历数据
			for(let i in param){
				let item = param[i]
				if(typeAll(item) === 'object' || typeAll(item) === 'array'){
					result[i] = colne(item)
				}else {
					result[i] = item
				}
			}
			return result
		}
		console.log('方法三',colne(obj))
		// {a: "你好", b: {…}, c: Fri Jul 31 2020 11:31:45 GMT+0800 (中国标准时间), d: Array(4), e: /^[a-zA-Z]\w{5,9}$/, …}
		// a: "你好"
		// b: {a: "第二层"}
		// c: Fri Jul 31 2020 11:31:45 GMT+0800 (中国标准时间) {}
		// d: (4) [1, 2, 3, 4]
		// e: /^[a-zA-Z]\w{5,9}$/
		// i: ƒ (b)
		// length: 1
		// name: "i"
		// arguments: null
		// caller: null
		// prototype: {constructor: ƒ}
		// __proto__: ƒ ()
		// [[FunctionLocation]]: deepClone.html:116
		// [[Scopes]]: Scopes[1]
		// __proto__: Object
		//剩下的引用库的方法就有很多了   比例lodash 的cloneDeep jQ的 entend 等
		
		
		
		
		
		
		
		
		
		
		
		
		
        //1.xiaoshuo-ss-sfff-fe  变为驼峰xiaoshuoSsSfffFe
        // function getCamelCase(str){debugger
        //     let arr = str.split('-')
        //     return arr.map(function(item,index){
        //         if(index == 0){
        //             return item
        //         }
        //         item = item.charAt(0).toUpperCase() + item.slice(1)
        //         return item
        //     }).join('')

        // }
        // console.log(CamelCase('xiaoshuo-ss-sfff-fe'))
        //正则写法
        // function getCamelCase(str){debugger
        //    return str.replace( /-([a-z])/g , function( all, i){ debugger   // 注意正则中的(),这里可以匹配到  -s 和s
        //                 return i.toUpperCase();                        
        //        }   )
        // }
        // console.log(getCamelCase('xiaoshuo-ss-sfff-fe'))
    
    </script>
</html>